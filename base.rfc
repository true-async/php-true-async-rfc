====== PHP True Async ======

  * Version: 1.5
  * Date: 2025-11-03
  * Author: Edmond [HT], edmondifthen@proton.me
  * Status: Under discussion
  * First Published at: http://wiki.php.net/rfc/true_async
  * Git: https://github.com/true-async
  * Related RFC: [[rfc:true_async_scope|PHP True Async: Scope and Structured Concurrency]]

===== Introduction =====
For several years, **PHP** has been attempting to carve out a niche in the development of long-running applications, where concurrent code execution becomes particularly useful. Production-ready solutions such as **Swoole**, **AMPHP**, **ReactPHP**, and others have emerged.

However, **PHP** still does not provide a comprehensive implementation for writing concurrent code. PHP extensions have no way to support //non-blocking execution//, even if they are capable of doing so. **Swoole** is forced to copy thousands of lines of code just for a few modifications, while **AMPHP** developers have to build drivers for ''MySQL'', ''PostgreSQL'', ''Redis'', and other systems from scratch in user-land.

**Note:** This RFC focuses on core async functionality (coroutines, await, cancellation). For Scope and structured concurrency, see the [[rfc:true_async_scope|Scope RFC]].
The goal of this **RFC** is to establish a standard for writing concurrent code in PHP, as well as a C-API interface that would allow PHP to be extended at a low level using C, Rust, C++, and other languages. This would enable extensions to support **non-blocking I/O** without the need to override PHP functions or duplicate code.

===== Goals =====

The **True Async** project pursues the following goals and values:

  * From a PHP developer's perspective, the **main value** of this implementation is that they DO NOT NEED to change existing code (or if changes are required, they should be minimal) to enable concurrency. Unlike explicit async models, this approach lets developers reuse existing synchronous code inside coroutines without modification.

  * Code that was originally written and intended to run outside of a Coroutine must work **EXACTLY THE SAME** inside a Coroutine without modifications.

  * A PHP developer should not have to think about how Coroutine switch and should not need to manage their switching—except in special cases where they consciously choose to intervene in this logic.

  * If there is existing code or a familiar style, such as AMPHP interfaces, Go coroutines, Swoole API, and others, it is best to use what is most recognizable to a broad range of developers.

  * The goal is to find a balance between flexibility and simplicity. On one hand, the implementation should allow leveraging existing solutions without requiring external libraries. On the other hand, it should avoid unnecessary complexity. Many design choices in this implementation are driven by the desire to free developers from concerns about compatibility with "external libraries" in favor of a standardized approach.

===== Proposal =====

==== Overview ====

=== Short glossary ===

| Term                       | Description                                                                    | Section                                     |
| **Coroutine**              | An executable unit of code that can be suspended and resumed                   | Launching any function in non-blocking mode |
| **CancellationError**      | A mechanism for cooperative canceling coroutine execution                      | Cancellation                                |
| **Awaitable**              | An interface for objects that can be awaited (may produce different values)    | Awaitable interface                         |
| **FutureLike**             | An interface for single-assignment awaitables with idempotent reads            | FutureLike interface                        |
| **Suspension**             | The state when a coroutine pauses execution and yields control                 | Suspension                                  |
| **Graceful Shutdown**      | A safe application termination mode that cancels all coroutines                | Graceful Shutdown                           |
| **Deadlock**               | A condition where no coroutines can progress due to circular dependencies      | Deadlocks                                   |
| **Scheduler**              | A component that manages coroutine execution and switching                     | Coroutine lifecycle                         |
| **Reactor**                | An event loop that handles I/O events and timers                               | Coroutine lifecycle                         |

This **RFC** describes the **API** for writing concurrent code in PHP, which includes:

=== Coroutine ===
A lightweight execution thread that can be suspended (''suspend'') and resumed.
Example
<code php>
use function Async\spawn;
use function Async\suspend;

spawn(function() {
    echo "Start";
    suspend();  // Suspend the coroutine
    echo "Resumed";
});
</code>

=== Cooperative cancellation ===
A special exception that implements cooperative cancellation:
Example
<code php>
use function Async\spawn;
use function Async\suspend;

$coroutine = spawn(function() {
    try {
        Async\delay(1000);
    } catch (Async\CancellationError $e) {
        echo "Coroutine cancelled";
        throw $e; // Re-throw to propagate cancellation
    }
});

suspend();

$coroutine->cancel();
</code>

=== Waiting for coroutine results ===

<code php>
use function Async\spawn;
use function Async\await;

function fetchData(string $file): string
{
    $result = file_get_contents($file);

    if($result === false) {
        throw new Exception("Error reading $file");
    }

    return $result;
}
echo await(spawn(fetchData(...), "file.txt"));
</code>

=== Awaiting a result with cancellation ===

<code php>
use function Async\spawn;
use function Async\await;

echo await(spawn(file_get_contents(...), "https://php.net/"), Async\timeout(2000));
echo await(spawn(file_get_contents(...), "https://php.net/"), spawn('sleep', 2));
</code>

=== Suspend ===

Transferring control from the coroutine to the other coroutines.:

<code php>
use function Async\spawn;
use function Async\suspend;

function myFunction(): void {
    echo "Hello, World!\n";
    suspend();
    echo "Goodbye, World!\n";
}

spawn(myFunction(...));
echo "Next line\n";
</code>

Output

<code>
Hello, World
Next line
Goodbye, World
</code>

==== Cancellable by design ====

This **RFC** is based on the principle of **"Cancellable by design"**, which can be described as follows:

> By default, coroutines **should be** designed in such a way that their
> cancellation at any moment does not compromise data integrity (for example, the Database).

In other words, by default, I/O operations or others awaiting operations,
**can be cancelled** by code **outside** the coroutine at **any moment**.

To properly complete transactions and release resources,
coroutine code **MUST** handle the cancellation exception ''CancellationError''.

=== Rationale ===

This **"cancellable by default"** policy is particularly well-suited for PHP because **read operations** (database queries, API calls, file reads) are typically as frequent as—or even more frequent than—write operations. Since read operations generally don't modify state, they're inherently safe to cancel without risking data corruption.

By making all operations cancellable by default, this approach eliminates the need for developers to explicitly mark or protect individual read operations, significantly reducing boilerplate code. Only write operations and critical sections that require transactional guarantees need special handling through proper ''CancellationError'' exception management.

==== Namespace ====

All functions, classes, and constants defined in this **RFC** are located in the ''Async'' namespace.
Extensions are allowed to extend this namespace with functions and classes,
provided that they are directly related to concurrency functionality.

==== Scheduler and Reactor ====

**Scheduler** and **Reactor** are internal components:

  - The **scheduler** is responsible for the execution order of coroutines.
  - The **reactor** is responsible for input/output events.

==== Coroutine ====

> A ''Coroutine'' is an ''execution container'', transparent to the code,
> that can be suspended on demand and resumed at any time.

The ''Coroutine'' class implements the ''FutureLike'' interface,
meaning it completes once and preserves its final result (value or exception).

Isolated execution contexts make it possible to switch between coroutines and execute tasks concurrently.

Any function can be executed as a coroutine without any changes to the code.

A coroutine can stop itself passing control to the ''scheduler''.
However, it cannot be stopped externally.

A suspended coroutine can be resumed at any time.
The ''scheduler'' component is responsible for the coroutine resumption algorithm.

A coroutine can be resumed with an **exception**, in which case an exception
will be thrown from the suspension point.

=== Coroutine lifetime ===

> A coroutine launched without an **explicitly defined** Scope has an **unknown** lifetime.

A coroutine created with spawn inherits the current Scope and its lifetime.
If code calls a third-party library function (or another module) that uses ''spawn()'' internally,
the library ends up creating a coroutine whose lifetime is unknown to it.
The programmer **should carefully** consider such situations
and determine whether an undefined coroutine lifetime is what they expect in that context.

If the coroutine lifetime matters, it is recommended to explicitly define a ''Scope''
to clearly manage coroutine lifetimes.

=== Coroutine Lifecycle ===

{{ :rfc:true_async:coroutine-lifecycle.svg |}}

This state diagram illustrates the lifecycle of a coroutine, showing how it transitions through various states during its execution:

**States:**
	- **Created** – The coroutine has been defined but not yet started.
	- **Queued** – The coroutine is queued
	- **Running** – The coroutine is actively executing.
	- **Suspended** – Execution is paused, usually waiting for a result or I/O.
	- **Completed** – The coroutine has finished (Successfully or with an exception).
	- **Pending Cancellation** – A cancellation was requested; the coroutine is cleaning up.

**Key Transitions:**
	- ''spawn'' moves a coroutine from **Created** to **Running**.
	- ''suspend'' and ''resume'' move it between **Running** and **Suspended**.
	- ''return/exit'' ends it in **Completed**.
	- ''cancel()'' initiates cancellation from **Running** or **Suspended**, leading to **Pending Cancellation**, and finally **Complete** with **Cancelled** flag.

=== ''Coroutine'' state check methods ===

| Method                              | Description                                                | Related State on Diagram         |
| ''isStarted(): bool''               | Returns ''true'' if the coroutine has been started.        | ''Running'', ''Suspended'', etc. |
| ''isRunning(): bool''               | Returns ''true'' if the coroutine is currently running.    | ''Running''                      |
| ''isQueued(): bool''                | Returns ''true'' if the coroutine is queued.               | ''Queued''                       |
| ''isSuspended(): bool''             | Returns ''true'' if the coroutine is suspended.            | ''Suspended''                    |
| ''isCancelled(): bool''             | Returns ''true'' if the coroutine has been cancelled.      | ''Cancelled''                    |
| ''isCancellationRequested(): bool'' | Returns ''true'' if cancellation has been requested.       | ''Pending Cancellation''         |
| ''isCompleted(): bool''             | Returns ''true'' if the coroutine has completed execution. | ''Completed'', ''Cancelled''     |

==== Spawn function ====

To create coroutines, the ''spawn(callable $callable, mixed ...$args)'' function is used.
It launches the ''<callable>'' in a separate execution context and returns
an instance of the ''Async\Coroutine'' class as a result.

Let's look at two examples:

> **Note:** The examples below are for demonstration purposes only.
> The non-blocking version of the ''file_get_contents'' function is not part of this **RFC**.

<code php>
$result = file_get_contents('https://php.net');
echo "next line".__LINE__."\n";
</code>

This code
  - first returns the contents of the PHP website,
  - then executes the ''echo'' statement.

<code php>
use function Async\spawn;

$coroutine = spawn('file_get_contents', 'https://php.net');
echo "next line".__LINE__."\n";
</code>

This code
  - starts a coroutine with the ''file_get_contents'' function.
  - The next line is executed without waiting for the result of ''file_get_contents''.
  - The coroutine is executed after the ''echo'' statement.

==== Suspension ====

A coroutine can suspend itself at any time using the ''suspend'' keyword:

<code php>
use function Async\spawn;
use function Async\suspend;

function example(string $name): void {
    echo "Hello, $name!";
    suspend();
    echo "Goodbye, $name!";
}

spawn('example', 'World');
spawn('example', 'Universe');
</code>

Expected output

<code>
Hello, World!
Hello, Universe!
Goodbye, World!
Goodbye, Universe!
</code>

With ''suspend()'', a coroutine yields control to the ''Scheduler'', which decides what to do next.
The exact decision made by the ''Scheduler'' is not part of this **RFC**,
and the scheduling algorithm may change at any moment
(this algorithm may also be modified by a third-party extension).

> A developer **MUST NOT** try to guess when a coroutine will resume execution or which other coroutine will be scheduled!
> Even if such information is obtained through testing or by reading the current implementation of the ''Scheduler'',
> the behavior may change at any moment!

**Basic usage:**

<code php>
use function Async\suspend;

suspend();
</code>

The ''suspend'' can be used in any function including from the **main execution flow**:

<code php>
use function Async\spawn;
use function Async\suspend;

function example(string $name): void {
    echo "Hello, $name!";
    suspend();
    echo "Goodbye, $name!";
}

$coroutine = spawn(example(...), 'World');

// suspend the main flow
suspend();

echo "Back to the main flow";
</code>

Expected output

<code>
Hello, World!
Back to the main flow
Goodbye, World!
</code>

The ''suspend'' keyword can be a throw point if someone resumes the coroutine externally with an exception.

<code php>
function example(string $name): void {
    echo "Hello, $name!";

    try {
        suspend();
    } catch (Exception $e) {
        echo "Caught exception: ", $e->getMessage();
    }

    echo "Goodbye, $name!";
}

$coroutine = spawn('example', 'World');

// pass control to the coroutine
suspend();

$coroutine->cancel();
</code>

**Expected output**

<code>
Hello, World!
Caught exception: cancelled at ...
Goodbye, World!
</code>

==== Awaitable interface ====

The ''Awaitable'' interface is a contract that allows objects to be used in the ''await'' expression.

The ''Awaitable'' interface does not impose limitations on the number of state changes.

In the general case, objects implementing the ''Awaitable'' interface can act as triggers — that is,
they can change their state an unlimited number of times.
This means that multiple calls to ''await <Awaitable>'' may produce different results.

==== FutureLike interface ====

The ''FutureLike'' interface extends ''Awaitable'' and represents objects with **single-assignment semantics** — 
they complete once with a result and provide **idempotent reads**.

<code php>
interface Async\FutureLike extends Async\Awaitable {
    public function cancel(?CancellationError $cancellationError = null): void;
    public function isCompleted(): bool;
    public function isCancelled(): bool;
}
</code>

Unlike the base ''Awaitable'' interface which allows multiple state changes,
''FutureLike'' implements single-assignment semantics from academic dataflow programming:

  * **Single-assignment**: The result is set exactly once (write-once)
  * **Idempotent reads**: Multiple ''await()'' calls always return the same result
  * **Type safety**: The ''await()'' function accepts only ''FutureLike'' objects, preventing misuse of multi-value awaitables
  * **Cancellation support**: Provides ''cancel()'' method to request cancellation
  * **State checking**: Provides ''isCompleted()'' and ''isCancelled()'' methods to check completion state

**Examples of FutureLike:**
  * ''Coroutine'' - completes once with a return value or exception
  * ''Future'' - represents a single deferred value
  * ''Task'' - a single unit of asynchronous work

**Examples of Awaitable (but NOT FutureLike):**
  * ''Channel'' - can be read multiple times, each read may return different value
  * ''Signal'' - can be triggered multiple times
  * ''Timer'' - fires repeatedly at intervals

This distinction enables compile-time type safety, making it clear whether an object
follows single-assignment semantics (''FutureLike'') or multi-value semantics (''Awaitable'').

==== Await ====

<code php>
Async\await(Async\FutureLike $awaitable, ?Async\Awaitable $cancellation = null): mixed
</code>

The ''await'' function is used to wait for the completion of another coroutine
or any object that implements the ''FutureLike'' interface.

<code php>
use function Async\spawn;
use function Async\await;

function readFile(string $fileName):string
{
    $result = file_get_contents($fileName);

    if($result === false) {
        throw new Exception("Error reading file1.txt");
    }

    return $result;
}

$coroutine = spawn(readFile(...), 'file1.txt');

echo await($coroutine);
// or
echo await(spawn(readFile(...), 'file2.txt'));
</code>

''await'' suspends the execution of the current coroutine until
the awaited one returns a final result or completes with an exception.

> **Coroutines behave like Futures:**
> once a coroutine completes (successfully, with an exception, or through cancellation),
> it preserves its final state.
> Multiple calls to ''await()'' on the same coroutine will always return the same result or
> throw the same exception.

<code php>
use function Async\spawn;
use function Async\await;

function testException(): void {
    throw new Exception("Error");
}

try {
    await(spawn(testException(...)));
} catch (Exception $e) {
    echo "Caught exception: ", $e->getMessage();
}
</code>

=== Await with cancellation ===

The ''await'' function can accept a second argument ''$cancellation'', which is an ''Awaitable'' object.
This object can be a ''Coroutine'', or another object that implements the ''Awaitable'' interface.

The $cancellation argument limits the waiting time for the first argument.
As soon as the $cancellation is triggered, execution is interrupted with an exception ''AwaitCancelledException''.

<code php>
use function Async\spawn;
use function Async\await;
use function Async\timeout;
use Async\AwaitCancelledException;

function readFile(string $fileName):string
{
    $result = file_get_contents($fileName);

    if($result === false) {
        throw new Exception("Error reading file1.txt");
    }

    return $result;
}

$cancellation = spawn(function() {
    Async\delay(2000);
});

try {
    // Wait for the coroutine to finish or for the cancellation to occur
    echo await(spawn(readFile(...), 'file1.txt'), $cancellation);
} catch (AwaitCancelledException $e) {
    echo "Caught exception: ", $e->getMessage();
}
</code>

==== Edge Behavior ====

The use of ''spawn''/''await''/''suspend'' is allowed in any part of a PHP program.
This is possible because the PHP script entry point forms the **main execution thread**,
which is also considered a coroutine.

As a result, operations like ''suspend'' and ''currentCoroutine()'' will behave the same way as in other cases.

Asynchronous code will work as expected, including inside ''register_shutdown_function''.

=== Memory Management and Garbage Collection ===

**Coroutines** and **Scopes** participate in PHP's standard garbage collection system:

  * **Unreferenced coroutines** can be collected by the garbage collector
  * **Circular references** between objects and coroutines are properly detected and resolved
  * **Active coroutines** (running or suspended) are protected from collection while they have pending operations

Coroutines retain either the execution result or the exception that occurred.
These items are visible to the garbage collector.

=== Destructors and Async Operations ===

**Destructors can contain async operations** and execute asynchronously:

<code php>
use function Async\spawn;
use function Async\suspend;

class AsyncResource {
    public function __destruct() {
        // Destructors can spawn coroutines
        spawn(function() {
            echo "Async cleanup\n";
        });

        // Destructors can suspend
        suspend();
    }
}
</code>

Destructor execution is **deferred** until the async context allows it, and destructors run **asynchronously** like other async code.

=== Exception Handling ===

The ''Scope'' class provides a method for handling exceptions:

<code php>
use Async\Scope;

$scope = new Scope();

$scope->spawn(function() {
    throw new Exception("Task 1");
});

$scope->setExceptionHandler(function (Exception $e) {
    echo "Caught exception: {$e->getMessage()}\n";
});

$scope->awaitCompletion(Async\timeout(60000));
</code>

An exception handler has the right to suppress the exception.
However, if the exception handler throws another exception,
the exception propagation algorithm will continue.

==== onFinally ====

The ''onFinally'' method allows defining a callback function that will be invoked when a coroutine or scope completes.
This method can be considered a direct analog of ''defer'' in Go.

> ⚠️ **Important:** All ''onFinally'' handlers are executed concurrently in separate coroutines.
> This ensures that slow handlers do not block the completion of other handlers or the main execution flow.

=== Coroutine::onFinally ===

For ''Coroutine'', the callback receives the completed coroutine as a parameter:

<code php>
use function Async\spawn;
use Async\Coroutine;

function task(): void
{
    throw new Exception("Task 1");
}

$coroutine = spawn('task');

$coroutine->onFinally(function (Coroutine $completedCoroutine) {
    echo "Coroutine " . spl_object_id($completedCoroutine) . " completed\n";
});

</code>

The ''onFinally'' semantics are most commonly used to release resources,
serving as a shorter alternative to ''try-finally'' blocks:

<code php>
function task(): void
{
    $file = fopen('file.txt', 'r');
    onFinally(fn() => fclose($file));

    throw new Exception("Task 1");
}

spawn('task');
</code>

==== Cancellation ====

The ''cancellation'' operation allows interrupting the execution of a coroutine that is in a waiting state.
A cancelled coroutine is **resumed** with a special ''CancellationError'' exception and continues its execution.
The cancellation operation is not instantaneous; it takes time.
While in the ''cancellation'' state, a coroutine may execute as usual without any restrictions.

The cancellation operation is available for coroutines and scopes
using the ''cancel()'' method:

<code php>
function task(): void {}

$coroutine = spawn(task(...));

// cancel the coroutine
$coroutine->cancel(new Async\CancellationError('Task was cancelled'));
</code>

The cancellation operation is implemented as follows:

  - If a coroutine has not started, it will never start.
  - If a coroutine is suspended, its execution will resume with an exception.
  - If a coroutine has already completed, nothing happens.

The ''CancellationError'', if unhandled within a coroutine, is automatically suppressed after the coroutine completes. However, the coroutine preserves its cancellation state, and any ''await()'' operation on this coroutine will throw the ''CancellationError''.

> ⚠️ **Warning:** You should not attempt to suppress ''CancellationError'' exception,
> as it may cause application malfunctions.

<code php>
use Async\Scope;

$scope = new Scope();

$scope->spawn(function() {
    sleep(1);
    echo "Task 1\n";
});

$scope->cancel(new Async\CancellationError('Task was cancelled'));
</code>

Canceling a ''Scope'' triggers the cancellation of all coroutines
within that ''Scope'' and all child ''Scopes'' in hierarchical order.

>
> **Note:** ''CancellationError'' can be extended by the user
> to add metadata that can be used for debugging purposes.
>

=== Cancellation policy ===

This **RFC** intentionally does not define rules for tracking the execution time of cancelled coroutines.
The reason is that cancellation operations may be long-running—for example,
rollback strategies—and may require blocking the function being cancelled.

Intentionally stopping coroutines that are in the cancellation state is a dangerous operation
that can lead to data loss. To avoid overcomplicating this **RFC**,
it is proposed to delegate the responsibility for such logic to the ''scheduler'' implementation.

=== Self-cancellation ===

A coroutine can attempt to cancel itself by calling its own ''cancel()'' method. However, **nothing happens immediately** - the coroutine continues executing normally until it naturally completes, but is marked as cancelled and stores the ''CancellationError'' as its final result:

<code php>
use function Async\spawn;

$coroutine = spawn(function() use (&$coroutine) {
    $coroutine->cancel(new \Async\CancellationError("Self-cancelled"));
    echo "This still executes\n"; // Will execute
    return "completed";
});

// await() will throw CancellationError despite normal completion
</code>

A coroutine can also cancel its own ''Scope'', which **does** affect execution by cancelling all coroutines in the scope, including itself:

<code php>
use Async\Scope;

$scope = new Scope();
$scope->spawn(function() use ($scope) {
    $scope->cancel(new \Async\CancellationError("Scope cancelled"));
    echo "This executes\n";
});
</code>

=== CancellationError handling ===

In the context of coroutines, it is not recommended to use ''catch \Throwable'' or ''catch CancellationError''.

Since ''CancellationError'' does not extend the ''\Exception'' class,
using ''catch \Exception'' is a safe way to handle exceptions,
and the ''finally'' block is the recommended way to execute finalizing code.

<code php>
use function Async\spawn;
use function Async\await;

try {
    $coroutine = spawn(function() {
        sleep(1);
        throw new \Exception("Task 1");
    });

    spawn(function() use ($coroutine) {
        $coroutine->cancel();
    });

    try {
        await($coroutine);
    } catch (\Exception $exception) {
        // recommended way to handle exceptions
        echo "Caught exception: {$exception->getMessage()}\n";
    }
} finally {
    echo "The end\n";
}
</code>

Expected output

<code>
The end
</code>

<code php>
try {
    $coroutine = spawn(function() {
        sleep(1);
        throw new \Exception("Task 1");
    });

    spawn(function() use ($coroutine) {
        $coroutine->cancel();
    });

    try {
        await($coroutine);
    } catch (Async\CancellationError $exception) {
        // not recommended way to handle exceptions
        echo "Caught CancellationError\n";
        throw $exception;
    }
} finally {
    echo "The end\n";
}
</code>

Expected output

<code>
Caught CancellationError
The end
</code>

=== CancellationError propagation ===

The ''CancellationError'' affects **PHP** standard library functions differently.
If it is thrown inside one of these functions that previously did not throw exceptions,
the PHP function will terminate with an error.

In other words, the ''cancel()'' mechanism does not alter the existing function contract.
PHP standard library functions behave as if the operation had failed.

Additionally, the ''CancellationError'' will not appear in ''get_last_error()'',
but it may trigger an ''E_WARNING'' to maintain compatibility with expected behavior
for functions like ''fwrite'' (if such behavior is specified in the documentation).

==== Graceful Shutdown ====

When an **unhandled exception** occurs in a **Coroutine**
the **Graceful Shutdown** mode is initiated.
Its goal is to safely terminate the application.

**Graceful Shutdown** cancels all coroutines in ''globalScope'',
then continues execution without restrictions, allowing the application to shut down naturally.
**Graceful Shutdown** does not prevent the creation of new coroutines or close connection descriptors.
However, if another unhandled exception is thrown during the **Graceful Shutdown** process,
the second phase is triggered.

**Second Phase of Graceful Shutdown**
- All **Event Loop descriptors** are closed.
- All **timers** are destroyed.
- Any remaining coroutines that were not yet canceled will be **forcibly canceled**.

The further shutdown logic may depend on the specific implementation of the **Scheduler** component,
which can be an external system and is beyond the scope of this **RFC**.

The **Graceful Shutdown** mode can also be triggered using the function:

<code php>
Async\gracefulShutdown(?CancellationError $CancellationError = null): void {}
</code>

from anywhere in the application.

=== exit and die keywords ===

The ''exit''/''die'' keywords always trigger the **Graceful Shutdown** mode,
regardless of where they are called in the code.
This works the same way as when an unhandled exception occurs.

**Graceful Shutdown** allows the application to safely terminate by canceling all coroutines
and performing necessary cleanup operations.

Unlike the ''cancel()'' operation, ''exit''/''die'' terminates the entire application,
not just the current coroutine.

=== Deadlocks ===

A situation may arise where there are no active **Coroutines** in the execution queue
and no active handlers in the event loop.
This condition is called a **Deadlock**, and it represents a serious logical error.

When a **Deadlock** is detected, the application enters **Graceful Shutdown** mode
and generates warnings containing information about which **Coroutines** are in a waiting state
and the exact lines of code where they were suspended.

At the end of the application lifecycle, if a deadlock condition was detected, 
a **DeadlockError** exception is thrown as a fatal error. This exception extends **Error** 
and indicates a critical architectural problem in the application design.
The **DeadlockError** is not intended to be caught during normal execution,
but rather serves as a diagnostic tool to identify circular dependencies between coroutines.

Example of deadlock situation:
<code php>
use function Async\spawn;
use function Async\await;
use function Async\suspend;

$coroutine1 = spawn(function() use (&$coroutine2) {
    suspend();
    await($coroutine2); // Waits for coroutine2
});

$coroutine2 = spawn(function() use ($coroutine1) {
    suspend(); 
    await($coroutine1); // Waits for coroutine1 - deadlock!
});

// Results in: Fatal error: Uncaught Async\DeadlockError: 
// Deadlock detected: no active coroutines, 2 coroutines in waiting
</code>

==== Tools ====

The ''Coroutine'' class implements methods for inspecting the state of a coroutine.

| Method                                   | Description                                                                                                                                                                                              |
| **''getSpawnFileAndLine():array''**      | Returns an array of two elements: the file name and the line number where the coroutine was spawned.                                                                                                     |
| **''getSpawnLocation():string''**        | Returns a string representation of the location where the coroutine was spawned, typically in the format ''"file:line"''.                                                                                |
| **''getSuspendFileAndLine():array''**    | Returns an array of two elements: the file name and the line number where the coroutine was last suspended. If the coroutine has not been suspended, it may return empty string,0.                       |
| **''getSuspendLocation():string''**      | Returns a string representation of the location where the coroutine was last suspended, typically in the format ''"file:line"''. If the coroutine has not been suspended, it may return an empty string. |
| **''isSuspended():bool''**               | Returns ''true'' if the coroutine has been suspended                                                                                                                                                     |
| **''isCancelled():bool''**               | Returns ''true'' if the coroutine has been cancelled, otherwise ''false''.                                                                                                                               |

The ''Coroutine::getAwaitingInfo()'' method returns an array with debugging information
about what the coroutine is waiting for, if it is in a waiting state.

The format of this array depends on the implementation of the **Scheduler** and the **Reactor**.

The ''Async\Scope::getChildScopes()'' method returns an array of all child scopes of the current scope.

The method ''Async\Scope::getCoroutines()'' returns a list of coroutines that are registered within the specified ''Scope''.

The ''Async\getCoroutines()'' method returns an array of all coroutines in the application.

===== Backward Incompatible Changes =====

Simultaneous use of the **True Async API** and the **Fiber API** is not possible,
as Fibers and coroutines manage the same resources (execution context, stacks) in different ways:

^ API        ^ Execution model                  ^ API level                                                ^
| **Fibers** | Symmetric execution contexts     | Low-level API where the programmer explicitly controls switching |
| **TrueAsync** | Switches contexts in an arbitrary order | High-level API where the programmer does not manage the switching |

Thus, these two APIs are incompatible not only at the technical level but also at the logical level.

If you try to create a ''Fiber'' inside a coroutine, you will get a ''FiberError'':

<code php>
use function Async\spawn;

spawn(function() {
    // This will throw FiberError
    $fiber = new Fiber(function() {
        echo "This won't work\n";
    });
});
</code>

Error message: "Cannot create a fiber while an True Async is active"

  - If ''new Fiber()'' is called first, subsequent ''Async\spawn'' calls will fail
  - If ''Async\spawn'' is called first, any attempt to create a **Fiber** throws ''FiberError''

===== Proposed PHP Version(s) =====

PHP 8.6+

===== RFC Impact =====

==== To SAPIs ====

The **True Async** module activates the reactor within the context of ''php_request_startup\php_request_shutdown()''
request processing. Therefore, using concurrency is reasonable only for long-life scenarios implemented via CLI.

It is expected that **True Async** will enable the integration of built-in **web servers** into PHP,
which will be embedded into the reactor’s event loop.

==== To Existing Extensions ====

No changes are expected in existing extensions.

==== To Opcache ====

Does not affect.

==== New Constants ====

No new constants are introduced.

==== To the Ecosystem ====

**Static Analyzers:**

Static analyzers will need to implement new checks for safe async/await usage:

  - **Deadlock detection:** Identify potential deadlocks in async code
  - **CancellationError suppression detection:** ''catch (\Throwable)'' that may hide CancellationError

**Libraries Using Fiber:**

Libraries that use the ''Fiber API'' will continue to work as expected,
but cannot be used simultaneously with ''True Async''.

==== php.ini Defaults ====

	* async.zombie_coroutine_timeout - default 5 seconds

===== Open Issues =====
None.

===== Future Scope =====

=== Reactor ===

At the moment, the Reactor component uses the ''LibUV'' library.
This component should be implemented as a separate extension.

===== Proposed Voting Choices =====
Yes or no vote.  2/3 required to pass.

<doodle title="Accept True Async RFC?" auth="crell" voteType="single" closed="true">
   * Yes
   * No
</doodle>

===== Patches and Tests =====

* Current implementation: https://github.com/true-async

===== References =====
Links to external references, discussions or RFCs

    * **First Discussion** - https://externals.io/message/126402
    * **Second Discussion** - https://externals.io/message/126537
    * **Third Discussion** - https://externals.io/message/127120
    * **Fourth Discussion** -

		* **TrueAsync API RFC** - https://github.com/true-async/php-true-async-rfc/blob/main/true-async-api-rfc.md

Additional links:

   * [[https://github.com/EdmondDantes/php-true-async-rfc/blob/main/comparison.md|Comparison of concurrency models in programming languages]]
   * [[https://alejandromp.com/development/blog/the-importance-of-cooperative-cancellation/|Cooperative cancellation]]
   * [[https://pure.tudelft.nl/ws/portalfiles/portal/222760871/LIPIcs.ECOOP.2024.8.pdf|Understanding Concurrency Bugs in Real-World Programs with Kotlin Coroutines]]
   * [[https://dl.acm.org/doi/10.1145/3297858.3304069|Understanding Real-World Concurrency Bugs in Go]]
   * [[https://arxiv.org/abs/1901.03575|Static Analysis for Asynchronous JavaScript Programs]]

The following can be considered as competing solutions to the current implementation:

   * **Swoole** (https://github.com/swoole/swoole-src) – a C++ library that implements a full feature set for concurrent programming. The advantage and disadvantage of **Swoole** is that it is a standalone solution that does not directly affect the language itself.

   * The **Swow** (https://github.com/swow/) project is a C library that provides a good lightweight API while not affecting the language itself and not requiring changes to PHP.

   * Examples of code: https://github.com/EdmondDantes/php-true-async-rfc/tree/main/examples

===== Implementation =====

The current implementation of the project is located here:
https://github.com/true-async

The code will be split into several PRs upon agreement.

===== Changelog =====

==== Version 1.5 (October 2025) ====
   * Added ''FutureLike'' interface methods: ''cancel()'', ''isCompleted()'', ''isCancelled()''
   * Renamed ''Coroutine::isFinished()'' to ''Coroutine::isCompleted()''
   * Clarified exit/die behavior: always triggers Graceful Shutdown mode regardless of where called
   * Added rationale for "Cancellable by design" policy: explains why default cancellability reduces code complexity for read-heavy PHP workloads
   * RFC structure improvements: reorganized Cancellation section with proper subsections hierarchy
   * Moved "Coroutine lifetime" as subsection under Coroutine section
   * Extended glossary with Awaitable, Suspension, Graceful Shutdown, and Deadlock terms
   * Introduced ''FutureLike'' interface with single-assignment semantics and changed ''await()'' signature to accept ''FutureLike'' instead of Awaitable for type safety
   * Split RFC: Moved Scope and structured concurrency functionality to separate [[rfc:true_async_scope|Scope RFC]]. Base RFC now focuses on core async primitives (coroutines, await, cancellation)

==== Version 1.4 (September 2025) ====
   * Major RFC simplification - removed CoroutineGroup, Future and AwaitXX functions
   * Added Memory Management and Garbage Collection section
   * Documented self-cancellation behavior in coroutines and its impact on execution
   * Enhanced "Cancellable by design" principle documentation
   * Updated suspend function information and usage guidelines
   * Added Scope waiting functionality and extra descriptions

===== Rejected Features =====
Keep this updated with features that were discussed on the mail lists.