====== PHP True Async - Wait Utilities ======

  * Version: 1.0
  * Date: 2025-09-24
  * Author: Edmond [HT], edmondifthen@proton.me
  * Status: Under discussion
  * Parent RFC: [[base.rfc|PHP True Async]]
  * Git: https://github.com/true-async

===== Introduction =====

This RFC describes the **Wait Utilities** for PHP True Async - a comprehensive set of functions that combine multiple awaitable objects into complex execution patterns. These utilities provide both error-propagating and error-collecting variants for different use cases.

This document is extracted from the main [[base.rfc|PHP True Async RFC]] to provide focused documentation on the awaitXX family of functions.

===== Wait Utilities =====

Async utilities are functions that combine multiple awaitable objects into complex execution patterns.
The API provides both error-propagating and error-collecting variants for different use cases.

==== Basic ====

| Function                                                                    | Description                                                              |
| ''await(Awaitable $awaitable, ?Awaitable $cancellation = null)''            | Waits for a single awaitable to complete                                 |

==== Error-Collecting Utilities (Default/Safe) ====

| Function                                                                   | Description                                                              |
| ''awaitAll(iterable $triggers, ?Awaitable $cancellation = null, bool $preserveKeyOrder = true, bool $fillNull = false)'' | Waits for all, returns both results and errors separately [results, errors] |
| ''awaitAny(iterable $triggers, ?Awaitable $cancellation = null)''          | Returns first successful result, collects errors from failures           |
| ''awaitFirstSuccess(iterable $triggers, ?Awaitable $cancellation = null)'' | Returns first successful result, collects errors from failures           |

==== Error-Propagating Utilities (Fail-Fast) ====

| Function                                                                   | Description                                                              |
| ''awaitAllOrFail(iterable $triggers, ?Awaitable $cancellation = null, bool $preserveKeyOrder = true)'' | Waits for all awaitables to complete, throws on first error             |
| ''awaitAnyOrFail(iterable $triggers, ?Awaitable $cancellation = null)''   | Returns result of the first completed awaitable, throws on error        |

==== Counted Utilities ====

| Function                                                                                 | Description                                                    |
| ''awaitAnyOf(int $count, iterable $triggers, ?Awaitable $cancellation = null, bool $preserveKeyOrder = true, bool $fillNull = false)'' | Waits for specified number of awaitables, collects errors      |
| ''awaitAnyOfOrFail(int $count, iterable $triggers, ?Awaitable $cancellation = null, bool $preserveKeyOrder = true)'' | Waits for specified number of awaitables, throws on first error |

==== Error Propagation vs Error Collection ====

**Error-Collecting Functions (Default)** (''awaitAll'', ''awaitAny'', ''awaitAnyOf'', ''awaitFirstSuccess''):
* Continue execution despite exceptions
* Return results and errors separately as ''[results, errors]''
* Allow partial success scenarios
* Safe by default - no work is lost

**Error-Propagating Functions (Fail-Fast)** (''awaitAllOrFail'', ''awaitAnyOrFail'', ''awaitAnyOfOrFail''):
* Stop execution on first exception
* Throw the exception immediately
* Cancel remaining coroutines
* Use when you need strict error handling

==== Function Parameters ====

=== preserveKeyOrder (bool, default: true) ===
Controls whether the result array maintains the same key order as the input iterable.

* **true**: Results array has same keys/indices as input array
* **false**: Results array is re-indexed with sequential numeric keys (0, 1, 2...)

<code php>
// With preserveKeyOrder = true (default)
[$results, $errors] = awaitAll([
    'user' => spawn('fetchUser'),
    'settings' => spawn('fetchSettings')
]);
// $results = ['user' => userData, 'settings' => settingsData]

// With preserveKeyOrder = false
[$results, $errors] = awaitAll([
    'user' => spawn('fetchUser'),
    'settings' => spawn('fetchSettings')
], preserveKeyOrder: false);
// $results = [0 => userData, 1 => settingsData]
</code>

=== fillNull (bool, default: false) ===
Controls how failed tasks are represented in the results array (only for error-collecting functions).

* **false**: Failed tasks are omitted from results array
* **true**: Failed tasks are represented as null in results array

<code php>
// With fillNull = false (default)
[$results, $errors] = awaitAll([
    spawn('successfulTask'),  // succeeds
    spawn('failingTask'),     // fails
    spawn('anotherSuccess')   // succeeds
]);
// $results = [0 => successResult, 2 => anotherResult]
// $errors = [1 => Exception]

// With fillNull = true
[$results, $errors] = awaitAll([
    spawn('successfulTask'),  // succeeds
    spawn('failingTask'),     // fails
    spawn('anotherSuccess')   // succeeds
], fillNull: true);
// $results = [0 => successResult, 1 => null, 2 => anotherResult]
// $errors = [1 => Exception]
</code>

==== Usage Examples ====

=== awaitAll() - Parallel Execution with Error Collection ===

<code php>
[$results, $errors] = awaitAll([
    spawn('fetchUserData'),
    spawn('fetchUserSettings'),
    spawn('fetchUserPreferences')
]);

// $results = [userData, userSettings, userPreferences] or null for failed
// $errors = [index => Exception] for any failures
// Order matches input order
// All tasks complete even if some fail
</code>

=== awaitAllOrFail() - Strict Parallel Execution ===

<code php>
$results = awaitAllOrFail([
    spawn('fetchUserData'),
    spawn('fetchUserSettings'),
    spawn('fetchUserPreferences')
]);

// $results = [userData, userSettings, userPreferences]
// Throws exception and cancels all on first failure
</code>

=== awaitAny() - First Success Race ===

<code php>
// Returns first successful result, continues until success
$data = awaitAny([
    spawn('fetchFromCache'),      // might fail
    spawn('fetchFromDatabase'),   // might fail
    spawn('fetchFromAPI')         // fallback
]);
// Returns first successful result, collects all errors
</code>

=== awaitAnyOrFail() - Fast Race Condition ===

<code php>
// Returns result from fastest completion (success or failure)
$data = awaitAnyOrFail([
    spawn('fetchFromCache'),
    spawn('fetchFromDatabase'),
    spawn('fetchFromAPI')
]);
// Throws exception if first completed task fails
</code>

=== awaitFirstSuccess() - Fault Tolerance ===

<code php>
[$result, $errors] = awaitFirstSuccess([
    spawn('callUnreliableAPI1'),
    spawn('callUnreliableAPI2'),
    spawn('callUnreliableAPI3')
]);

if ($result !== null) {
    echo "Got result: $result\n";
} else {
    echo "All calls failed. Errors: " . count($errors) . "\n";
}
</code>

=== awaitAll() with fillNull - Complete Data Collection ===

<code php>
[$results, $errors] = awaitAll([
    spawn('processFile', 'file1.txt'),
    spawn('processFile', 'file2.txt'),
    spawn('processFile', 'corrupted.txt') // might fail
], fillNull: true);

// $results = ["result1", "result2", null]
// $errors = [2 => Exception("corrupted file")]
</code>

=== awaitAnyOf() - Partial Completion with Error Collection ===

<code php>
// Wait for first 3 downloads to complete (including failures)
[$results, $errors] = awaitAnyOf(3, [
    spawn('downloadFile', 'file1.zip'),
    spawn('downloadFile', 'file2.zip'),
    spawn('downloadFile', 'file3.zip'),
    spawn('downloadFile', 'file4.zip'),
    spawn('downloadFile', 'file5.zip')
]);

// $results = [1 => "file2.zip", 0 => "file1.zip", 4 => "file5.zip"]
// $errors = [] (if all successful) or [index => Exception]
// Keys preserve original array indices
</code>

=== awaitAnyOfOrFail() - Strict Partial Completion ===

<code php>
// Wait for first 3 downloads to complete, fail fast on errors
$completedDownloads = awaitAnyOfOrFail(3, [
    spawn('downloadFile', 'file1.zip'),
    spawn('downloadFile', 'file2.zip'),
    spawn('downloadFile', 'file3.zip'),
    spawn('downloadFile', 'file4.zip'),
    spawn('downloadFile', 'file5.zip')
]);

// Returns array: [1 => "file2.zip", 0 => "file1.zip", 4 => "file5.zip"]
// Throws exception if any of the first 3 downloads fail
</code>

==== Cancellation Support ====

All Utilities support cancellation through the optional ''$cancellation'' parameter:

<code php>
try {
    $results = awaitAll($tasks, Async\timeout(30000)); // 30 second timeout
} catch (Async\AwaitCancelledException $e) {
    echo "Operation timed out\n";
}
</code>

==== Advanced Patterns ====

**Retry with Multiple Strategies:**
<code php>
function fetchWithRetry(string $url): string
{
    for ($attempt = 1; $attempt <= 3; $attempt++) {
        [$result, $errors] = awaitFirstSuccess([
            spawn('fetchFromCDN', $url),
            spawn('fetchFromOrigin', $url),
            spawn('fetchFromBackup', $url)
        ]);

        if ($result !== null) {
            return $result;
        }

        echo "Attempt $attempt failed, retrying...\n";
        Async\delay(1000 * $attempt); // exponential backoff
    }

    throw new Exception("All retry attempts failed");
}
</code>

**Batch Processing with Concurrency Control:**
<code php>
function processBatch(array $items, int $batchSize = 10): array
{
    $allResults = [];

    for ($i = 0; $i < count($items); $i += $batchSize) {
        $batch = array_slice($items, $i, $batchSize);
        $tasks = array_map(fn($item) => spawn('processItem', $item), $batch);

        $batchResults = awaitAll($tasks);
        $allResults = array_merge($allResults, $batchResults);
    }

    return $allResults;
}
</code>

===== References =====

* [[base.rfc|PHP True Async - Main RFC]]
* For basic coroutine and scope concepts, see the main [[base.rfc|PHP True Async RFC]]
* For timer functions (timeout), see the main [[base.rfc#timer_functions|Timer Functions section]]